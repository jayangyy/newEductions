/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package cr.cdrb.commons.crypt;

import static java.lang.Integer.min;
import java.security.SecureRandom;
import javax.crypto.Cipher;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Base64;

/**
 *
 * @author Administrator
 */
public class PublicKeyCrypt {
    private static final String AES = "AES";
    private static final String DES = "DES";
    private static final String UTF8 = "utf-8";
    
    public static  String encryptAES(String content, String key) {
        if(content==null || key==null) return null;
        try {
            byte[] keyBytes = key.getBytes(UTF8);
            if(keyBytes.length != 16) {
                byte[] t = keyBytes;
                keyBytes = new byte[16];
                System.arraycopy(t, 0, keyBytes, 0, min(16, t.length));
            }
            Cipher cipher = Cipher.getInstance(AES);
            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(keyBytes, AES));
            byte[] aes = cipher.doFinal(content.getBytes(UTF8));
            return Base64.encodeBase64String(aes);
        }
        catch(Exception e) {
            return null;
        }
    }
    
    public static String decryptAES(String content, String key) {
        if(content==null || key==null) return null;
        try {
            byte[] keyBytes = key.getBytes(UTF8);
            if(keyBytes.length != 16) {
                byte[] t = keyBytes;
                keyBytes = new byte[16];
                System.arraycopy(t, 0, keyBytes, 0, min(16, t.length));
            }
            Cipher cipher = Cipher.getInstance(AES);
            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(keyBytes, AES));
            return new String(cipher.doFinal(Base64.decodeBase64(content)), UTF8);
        }
        catch(Exception e) {
            return null;
        }
    }
    
    public static  String encryptDES(String content, String key) {
        if(content==null || key==null) return null;
        try {
            byte[] keyBytes = key.getBytes(UTF8);
            if(keyBytes.length % 8 > 0) {
                byte[] t = keyBytes;
                keyBytes = new byte[t.length +  8 - (t.length % 8)];
                System.arraycopy(t, 0, keyBytes, 0, t.length);
            }
            Cipher cipher = Cipher.getInstance(DES);
            cipher.init (
                Cipher.ENCRYPT_MODE, 
                SecretKeyFactory.getInstance(DES).generateSecret(new DESKeySpec(keyBytes)),
                new SecureRandom(keyBytes)
            );
            return Base64.encodeBase64String(cipher.doFinal(content.getBytes(UTF8)));
        }
        catch(Exception e) {
            return null;
        }
    }
    
    public static String decryptDES(String content, String key) {
        if(content==null || key==null) return null;
        try {
            byte[] keyBytes = key.getBytes(UTF8);
            if(keyBytes.length % 8 > 0) {
                byte[] t = keyBytes;
                keyBytes = new byte[t.length +  8 - (t.length % 8)];
                System.arraycopy(t, 0, keyBytes, 0, t.length);
            }
            Cipher cipher = Cipher.getInstance(DES);
            cipher.init (
                Cipher.DECRYPT_MODE, 
                SecretKeyFactory.getInstance(DES).generateSecret(new DESKeySpec(keyBytes)),
                new SecureRandom(keyBytes)
            );
            return new String(cipher.doFinal(Base64.decodeBase64(content)), UTF8);
        }
        catch(Exception e) {
            return null;
        }
    }
}
